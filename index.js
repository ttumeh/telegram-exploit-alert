const TelegramBot = require('node-telegram-bot-api');
const fs = require('fs');
const axios = require('axios');
const { html: format } = require('telegram-format');

const bot = new TelegramBot('BOT_TOKEN', { polling: true });
const chatId = CHAT_ID;

// Initialise data
const jsonData = JSON.parse(fs.readFileSync('categories.json', 'utf8'));
const categories = jsonData.categories;

// API endpoint
const apiUrl = 'https://www.exploitalert.com/api/search-exploit?name=';

/**
 * Search exploitalert API for new entries
 * @param {*} categories Categories available in the Exploit Alert API
 */
async function search(categories) {
    let jsonData2 = JSON.parse(fs.readFileSync('latest.json', 'utf8'));
    let latest = jsonData2.id;
    // Loop through the categories and call API
    for (const key in categories) {
        if (categories.hasOwnProperty(key)) {
            const categoryValue = categories[key];
            // Construct the API URL for the current category
            const categoryApiUrl = `${apiUrl}${categoryValue}`;
            try {
                // Make the API call for the current category
                const response = await axios.get(categoryApiUrl);
                const responseData = response.data;
                // Check if responseData is an object
                if (responseData) {
                    // Extract the ID from the API response and update the highestId if needed
                    for (let x in responseData) {
                        if (responseData[x].id > latest) {
                            latest = parseInt(responseData[x].id);
                            // Get the new exploit information
                            exploitInfo = responseData[x];
                            newUrl = `https://www.exploitalert.com/view-details.html?id=${responseData[x].id}`;
                            // Send message to Telegram channel
                            bot.sendMessage(chatId, `<b>ðŸš¨NEW EXPLOIT SURFACEDðŸš¨\n\n${responseData[x].name}\n\n${newUrl}</b>`, {
                                parse_mode: 'HTML'
                            })
                            updateLatestJson(latest);
                        } else {
                            continue;
                        }
                    }
                }
            } catch (error) {
                console.error('Error fetching data for Category', key, ':', error.message);
            }
        }
    }
}


// Update the highest ID value in the latest.json file
function updateLatestJson(newHighestId) {
    // Read the current content of the latest.json file
    fs.readFile('latest.json', 'utf8', (err, data) => {
        if (err) {
            console.error('Error reading latest.json:', err);
            return;
        }
        try {
            const latestData = JSON.parse(data);
            latestData.id = newHighestId;
            // Write the updated JavaScript object back to the latest.json file
            fs.writeFile('latest.json', JSON.stringify(latestData), (err) => {
                if (err) {
                    console.error('Error writing to latest.json:', err);
                } else {
                    console.log('Successfully updated highest ID value in latest.json');
                }
            });
        } catch (error) {
            console.error('Error parsing latest.json:', error);
        }
    });
}


// Search API every 10 minutes
setInterval(function() { search(categories); }, 10 * 60 * 1000);